 Увод  

 

xv6 је оперативни систем намењен образовним сврхама [1]. Настао је при универзитету МИТ 2006 године. Он је базиран на концептима који стоје иза 6. верзије оперативног система Уникс оперативног система (Unix version 6) који датира још из 1975. године, са тиме што је намењен модерној процесорској архитектури RISC-V. 

Задатак овог дипломског рада јесте модификација фајл система xv6 оперативног система, која ће резултовати учитавањем корисничких програма у меморију приликом његове иницијализације, увезивањем учитаних програма са остатком фајл система, а самим тиме и смањеним закашњењем приликом покретања процеса. 

Кроз овај текст, у грубим цртама, биће осликани принципи иза оперативног система xv6, а потом ће бити представљено решење задатка. 

 xv6 

Пројекат xv6 подразумева коришћење QЕМU емулатора [2] са специфицним опцијама, тj, xv6 оперативни систем је намењен апстрактном рачунарском систему који је прецизиран тим опцијама. Коришћење RISC-V процесорске архитектуре, са једним или више процесора као и коришћење блоковског уређаја (у наставку текста ће тај уређај бити реферисан термином "диск") за складиштење података су неке од карактеристика тог рачунарског система. 

Сама RISC-V архитектура пружа подршку за привилегован режим рада као и имплементацију виртуелне меморије. 

Језгро  самог оперативног система је монолитно, тј. сви делови xв6 система за које можемо сматрати да припадају оперативном систему се извршавају у привилегованом режиму рада процесора.  

Он је вишепрограмски оперативни систем који подржава рад са мултипроцесорским архитектурама. 

Као технику виртуелне меморије користи страничење. 

Иницијализација 

Покретање xv6 пројекта подразумева покретање QEMU емулатора. Он учитава читаво језгро оперативног система са диска на физичку адресу (емулираног процесора) 0x80000000, а затим пребацује контролу тока самом језгру. Потом се извшава иницијализациони део језгра (редом: kernel/entry.c, kernel/start.c и kernel/main.c) који подразумева и стварање иницијалног корисничког процеса (user/initcode.c). Иницијални кориснички процес позивом системских позива еxec учитава програм (init.c) који представља команди интерфејс оперативног система, чиме се завршава његова инициајлизација. 

Адресни простор, прекиди 

xv6 обезбеђује сопствени адресни простор корисничким процесима коришћењем технике страничења. Само језгро оперативног система, такође поседује табелу сраница. 

			Слика 1: Адресни простор језгра xv6 оперативног система 

На слици 1, приказано је мапирање адресног простора језгра оперативног система. Осим у специјалном случају, сав адресни простор језгра ОС-а се пресликава искључиво у идентичне физичке адресе. Изузетак су стекови језгра (језгро поседује по један стек за сваки кориснички процес), као и одскочна страница који су додатно мапирани и у виши адресни простор језгра. 

Неиспрекиданим мапирањем стекова језгра се дефинише понашање оперативног система у случајевима прекорачења алоцираног простора стека. Уколико дође до прекорачења, меха- низaм за виртуелизацију меморије RISC-V процесора уочава покушај приступа немапираној страници и пријављује изузетак. 

Одскочна страница, која је дељена страница и у којој је смештен извршни код који се извршава приликом изласка и уласка у кориснички режим рада, је мапирана на највишу страницу адресног простора језгра али и сваког  корисничког процеса у систему.  

Тиме се омогућава њено правилно извршавање и након одговарајуће замене показивача на табеле страница. 

  

Како је одскочна страница дељена између свих процеса (па и језгра), јавља се потреба за начином чувања и рестуирања контекста процеса који би важио за сваки процес. За те потребе, у оквиру xv6 оперативног система, се уводи, ткз, трапфрејм страница Сваки кориснички процес поседује своју трапфрејм страницу која је мапирана на другу највишу страницу у оквиру његовог адресног простора и користи се за смештање вредности регистара приликом изласка из корисничког режима рада. На тај начин одскочна страница може сачувати и рестуирати вредности регистара са унапред познатих адреса. 

 

		  Слика 2: Адресни простор корисничког процеса у xv6 оперативном систему 

 

Кориснички процеси 

 

Кориснички процеси се извршавају у корисничком режиму рада процесора, док до осетљивијих рачунарских ресурса долазе механизмом системских позива.  

Нови кориснички процеси настају комбинацијом fork и exec системских позива. 

Системским позивом fork се ствара процес (дете процес) са идентичним адресним простором као и кориснички процес који га је позвао (родитељ процес). Контексти дете и родитељ процеса се разликују само у повратној вредности fork системског позива (у родитељу fork враћа идентификациони број дете процеса, док детету враћа нулу). 

Системим позивом exec се врши учитавње програма чија је путања у фајл систему прослеђена самим позивом. Програм се учитава на место позивалаца exec системског позива. 

 

pid = fork(); 

    if(pid < 0){ 

      printf("init: fork failed\n"); 

      exit(1); 

    } 

    if(pid == 0){ 

      exec("sh", argv); 

      printf("init: exec sh failed\n"); 

      exit(1); 

    } 

Слика 3: део програма корисничког интерфејса који покреће корисничке процесе 

 

Једном створен кориснички процес улази у контенцију за релативну контролу над процесором, о чему одлучује распоређивач оперативног система.  

Рапоређивач xv6 оперативног система, кружним током, додељује једнак временски исечак сваком процесу, након чијег истека преузима контралу и додељује је следећем процесу (Round Robin алгоритам). 

Фајл систем 

Фајл систем xv6 оперативног система, као појам, се може односити на саму организацију података на диску (слика фајл система) као и на  делове језгра оперативног система који се односе на тај фајл систем. Поменути делови језгра се могу посматрати кроз призму слојева фајл система.                                                                                         

           Слика 4: приказ слике фајл система                              		 Слика 5: слојеви фајл система 

Слика фајл система 

  

У нултом блоку диска је смештен код језгра оперативног система. То је уједно и блок који би БИОС програм учитао у меморију уколико би се оперативни систем xv6 изршавао на стварном процесору. 

Даље се на диску, редом, налазе: суперблок, log блокови, inode блокови, bitmap блок као и data блокови. 

Суперблок је блок диска у коме се налазе мета подаци саме слике фајл система као што су величина слике фајл система, индекс блока од кога почиње мапа слободних битова и слично. 

log блокови и inode блокови су блокови које користе већ поментути слојеви фајл система о чему ће бити речи касније у тексту. 

Мапа слободних блокова је низ блокова (bitmap блокови) чији битови представљају информације о искоришћености специфичних блокова, где сваки бит представља стање тачно једног блока које је представљено само тим битом (ако бит има позитивну логичку вредност, блок је слободан). 

У data блоковима су смештени сами кориснички програми, подаци који они генеришу као и неки иницијални подаци самог фајл система. 

Слојеви фајл система 

Као што је већ поменуто, код језгра оперативног система који се односи на фајл систем се може посматрати кроз призму слојева фајл система. Сваки слој фајл система зависи искључиво од нижих слојева у тој хијерархији и нуди програмски интерфејс који се може користити сам по себи. 

2.4.2.1 Бафер кеш слој 

Најнижи слој фајл система, такозвани Бафер кеш слој, уједно представља и најнижи ниво апстракције од свих слојева. Њиме се директно могу учитавати и уписивати блокови задатог индекса са задатог диска, a виши слојеви фајл система га користе за приступ диску. 

2.4.2.2 log слој 

Поставља се питање, како оперативни системи резрешавају ситуације у којима, приликом уписа података на диск, дође до отказа рачунарског система (услед, рецимо, пада напајања). Уколико је по том питању фајл систем препуштен сам себи, могућ је сценарио у коме, процес, од укупног броја блокова за упис, упише само део њих и тиме се постави у логички неконзистенто стање. 

xв6 оперативни систем се, у таквом сценарију, руководи log слојем фајл система, који се заснива на ткз. техници евидентирања. Идеја је да се, пре него што се блокови упишу на место на диску где би то програм очекивао (data слој), они упишу на друго место (у оквиру log слоја). Након што се упише читава логичка серија блокова у други, за то намењен, део log слоја, у првом делу log слоја се уписују индекси блокова које треба преписати из log слоја у data слој. Тек након тога фајл систем креће да преписује те блокове у data слој, након чега брише индексе преписаних блокова из првог сегмента log слоја. Тиме се постиже атомично уписивање и преписивање самих блокова података у односу на потенцијални тренутак отказа система. Наравно, ризик да дође до отказа система приликом уписа индекса самих блокова података (у први део log слоја) преостаје, али како се ради о значајно мањем упису, често и у оквиру једног блока - тај ризик је значајно мањи. 

 

2.4.2.3 inode слој 

 

Сами кориснички програми и подаци који они генеришу се налазе у оквиру data сегмента слике фајл система. Две врсте логичких јединица, којима оперативни систем приступа data сегменту фајл система се називају фајлови и директоријуми. Кроз концепт фајлова, кориснички процеси могу уписивати произвољан садржај на диск, док се садржај директоријума односи на фајлове и друге директоријуме који му логички припадају. Концептом директоријума, виши слојеви фајл система могу логички да организују саму структуру фајл система.  

  

У оквиру трећег слоја, такозваног inode слоја, фајл систем чува податке о фајловима и директоријумима. inode слој садржи ограничени број улаза, где сваки улаз може представљати тачно један фајл или директоријум. Сваки улаз inode слоја садржи мета податке о улазу, међу којима се налазе информација о типу улаза (да ли се ради о фајлу или директоријуму), броју директоријума којима логички припада, као и величина (не рачунајући сам индиректни блок, о коме ће бити речи у наставку текста) коју тај улаз заузима у оквиру data слоја. Поред мета података сваки улаз у inode слој садржи и низ од 13 индекса блокова.   

  

Логички садржај самих фајлова дефинишу кориснички програми који у њих уписују податке, док логички садржај директоријума представља низ улаза тог директоријума, где сваки улаз тог директоријума представља тачно један фајл или директоријум који му логички припада. Улаз самог директоријума се састоји од индекса улаза самог inode слоја и ниске карактера који представља назив тог фајла или директоријума у оквиру директоријума коме припада (локални назив). 

  

Блокови, на које се поменутих 13 индекса (у оквиру сваког улаза inode слоја) односе, прецизирају блокове у оквиру data слоја фајл система, у оквиру којих улази иноде слоја  

смештају логичке податке. Првих 12 блокова представљају директне индексе, тј. индексе  

блокова у којима се смешта сам логички садржај. Блок на који се последњи индекс односи 

јесте индиректни блок и у њему се редом уписују индекси осталих директних блокова. 

 

 

Слика 6: Приказ улаза у inode слој 

 

      

Још један тип улаза inode слоја јесте тип уређаја. Такви улази не користе низ од 13 блокова (логичка величина им је 0), а сам тај улаз користе виши слојеви фајл система за апстаховање рада са уређајима. 

 

2.4.2.4 Путање 

 

Већ је помињано да директоријуми пружају оперативном систему начин да организују фајл систем. Сваки фајл мора да се налази у бар једном директоријуму. 

Инцијални директоријум, који се ствара приликом иницијализације слике фајл система, а који једини не припада другим директоријумима, је такозвани корени директоријум.  

Сваки директоријум изузев кореног припада бар једном (различитом од себе) директоријуму. 

Кориснички процеси могу реферисати на директоријум у коме се налазе називом ".", док називом ".." могу реферисати на родитељски директоријум. 

Кориснички процеси могу реферисати на фајлове и директоријуме (у наставку објекте) у оквиру неког директоријума као назив_директоријума_коме_тај_објекат_припада/локални_назив_објекта - ткз. путањама. 

Изузетно, уколико се тај програм и објекат на који тај програм реферише налазе у оквиру истог директоријума, довољан је и локални назив тог објекта. 

  

Описани начин реферисања на фајлове и директоријуме у грубим цртама описује слој путања фајл система. Он корисницима, као и корисничким процесима, пружа начин да навигирају кроз фајл систем. 

Сам слој нуди и програмски интерфејс за дохватање фајлова и дирекотријума чија путања је прослеђена нискама карактера. 

 

2.4.2.4 Слој фајл дескриптора 

 

Последњи и највиши слој фајл система, слој фајл дескриптора, нуди програмски интерфејс који додатно апстрахује претходне слојеве.  

 

У оквиру овог слоја јављају се ткз. фајл дескриптори. Они представљају програмски конструкте којима се, на униформан начин, могу апстраховати улази у inode слој или  

конструкти за међупроцесну комуникацију. Један фајл дескриптор представља тачно један улаз у inode слој или конструкт за међупроцесну комуникацију - pipe. 

  

Код у оквири овог слоја зна да препозна тип "уређај" улаза inode слоја. Наиме, функције за писање у оквиру inode слоја,  за дати улаз, увек дописују податке у data слоју слике 

фајл система, док пандан функције у оквиру слоја фајл дескриптора, за дате улазе могу, у случају типа "уређај", да покрену комуникацију са уређајем којим тај улаз представља. 

ЕЛФ формат фајлова 

Иако ЕЛФ формат фајлова није тема овог текста, треба га се, у кратким цртама дотаћи, макар у мери која је потребна да би се објаснило решење задатка. 

ЕЛФ формат фајлова представља формат намењем извршним фајловима, разним програмским библиотекама и конструктима(нпр. објектни фајлови), корисним у домену системског програмирања. 

Кориснички програми у оквиру xv6 оперативног система се налазе на диску у следећем, ЕЛФ, формату. 

 

Сам тај формат се састоји из 3 дела која се у следећем редоследу налазе у логичком простору података фајла: ЕЛФ заглавље, низ заглавља секција и саме секције програма, које су ништа друго него бајтови самог адресног простора програма. 

 

ЕЛФ заглавље садржи мета податке о читавом фајлу, укључујући и поље за верификацију ЕЛФ фајла (предефинисана ниска карактера), број заглавља секција и сл. 

 

Заглавља секција садрже мете податке о самим секцијама укључујући и величине коју секције зазимају на диску и у адресном простору самог програма( ако постоји разлика, она мора бити у корист друге величине), виртуелна адреса од које се секција смешта као и битови који говоре о правима приступа секцији. 

 

Уколико је величина секције у адресном простору већа од оне на диску, разлика се попуњава нулама. 

 

Битови који говоре о правима приступа, говоре о типу приступа који се предвиђа за саму секцију. R бит говори да је предвиђено да програм чита логичке податке, Х бит говори да је предвиђено да програм чита процесорске инструкције из те секције и W бит да је предвиђено да програм уписује податке у ту секцију. Ти битови нису међусобно искључујући, а оперативни систем их може користити да додатно учврсти сигурност програма (ако је дошло до уписа на адресу која за то није предвиђена, сасвим је могуће да је дошло до сигурносног проблема). xv6 то ради уписом одговарајућих битова у оквиру самог улаза у табели страница. 

 

# objdump -p user/_init 

user/_init: file format elf64-little 

Program Header: 

0x70000003 off 0x0000000000006bb0 vaddr 0x0000000000000000 

paddr 0x0000000000000000 align 2**0 

filesz 0x000000000000004a memsz 0x0000000000000000 flags r-- 

LOAD off 0x0000000000001000 vaddr 0x0000000000000000 

paddr 0x0000000000000000 align 2**12 

filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x 

LOAD off 0x0000000000002000 vaddr 0x0000000000001000 

paddr 0x0000000000001000 align 2**12 

filesz 0x0000000000000010 memsz 0x0000000000000030 flags rwSTACK off 0x0000000000000000 vaddr 0x0000000000000000 

paddr 0x0000000000000000 align 2**4 

filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw 

 

Слика 7: Приказ ЕЛФ заглавља програма user/_init 

 

Задатак  

Сам програмски задатак овог дипломског рада јесте имплементација алтернативног фајл система, који би се налазио у меморији и у који би били учитани кориснички програми. 

Решење 

Идеја иза решења јесте да се након иницијализације оригиналног фајл система врши итерација кроз читав низ улаза inode слоја фајл система. За сваки улаз који представља кориснички програм се учитавају секције које заузимају простор на диску у статички део меморије. Касније, током настанка адресног простора корисничких процеса у оквиру exec системског позива се те секције учитавају из тог, статичког, дела меморије уместо са диска. Такође, решење настоји да, коришћењем технике дељења страница, минимализује непотребна копирања страница у оквиру саме мемороије. 

Детаљнији преглед решења као и сам код решења, биће дати након кратког прегледа радног окружења као и структуре самог xv6 пројекта. 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Структура xv6 пројекта 

 

 

Слика 8: структура xv6 пројекта 

 

На горњој слици је приказана структура xv6 пројекта. Сам пројекат користи make алат за аутоматизацију покретања команди оперативном систему домаћину. Емулатор QEMU се користи за емулацију апстрактног рачунарског система. 

Фајлови из кернел фолдера се преводе и спајају у једну целину, која се након комплетног превођена смешта на адресу 0x80000000 командом qemu –kernel. 

Фајлови у user фолдеру представљају корисничке програме који се смештају у иницијалну слику фајл система оперативног система xv6. Они се преводе одвојено за RISC-V архитектуру, а резултујући извршни фајлови се прослеђују програму дефинисаним фајлом mkfc.c. 

Програм дефинисан фајлом mkfc.c је задужен за настанак иницијалне слике фајл система. Њему се прослеђују кориснички фајлови на основу којих генерише иницијалну слику фајл система коју смешта у фајл fsimage. 

QEMU емулатору се, заједно са параметрима који описују апстраховани рачунарски систем, прослеђује преведено језгро, као и иницијална слика xv6 оперативног система, након чега долази до почетка емулације. 

 

Развојно окружење 

За потребе овог дипломског коришћено је CLion развојно окружење као и gcc ланац превођења. Само развојно окружење се налази у оквиру Ubuntu оперативног система. 

Детаљи решења 

Иницијализација алтернативног фајл система се одвија у оквиру функције init_alt_fs (слика 9). 

void init_alt_fs(int dev) 

{ 

    struct elfhdr elf; 

  struct proghdr ph; 

 

 

struct inode *i_temp; 

begin_op(); 

for(int i = 0;i < NINODE;i++) 

{ 

   

  i_temp = iget(dev,i); 

 

  ilock(i_temp); 

Слика 9: Потпис и почетак функције init_alt_fs 

У њој се врши итерација свих улаза inode слоја, тј. блокова у оквиру inode дела слике фајл система . 

За сваки улаз се проверава да ли представља кориснички програм. То се ради провером верификационог дела ЕЛФ заглавља. Уколико било који од ЕЛФ или заглавља секција не може да се учита (превазилажењем логичке величине коју сам улаз у inode секцију представља) или садржи логички неконзистенту вредност, прелази се на наредни улаз иноде слоја (слика 10).  

if(i_temp->type != T_FILE) 

    goto end; 

       

 

  // Check ELF header 

  if(readi(i_temp, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf)) 

    goto end; 

 

  if(elf.magic != ELF_MAGIC) 

    goto end; 

 

  for(int j=0, off=elf.phoff; j<elf.phnum; j++, off+=sizeof(ph)){ 

    if(readi(i_temp, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph)) 

      goto end; 

 

    if(ph.type != ELF_PROG_LOAD) 

      continue; 

 

    if(ph.memsz < ph.filesz) 

      goto end; 

    if(ph.vaddr + ph.memsz < ph.vaddr) 

      goto end; 

    if(ph.vaddr % PGSIZE != 0) 

      goto end; 

Слика 10: Провера потенцијалих ЕЛФ и заглавља секција, приликом итерације улаза у inode слој приликом итерације у оквиру функције init_alt_fs 

 

Након тога се редом учитавају заглавља секција на основу вредности прочитане у оквиру ЕЛФ заглавља (слика 11). За свако заглавље секције чија величина у оквиру фајл система није 0,  учитава се, континуално, сама секција  у динамички алоциране странице. Адресе на којима се смештају секције се уписују у статички алоцирани, дводимензионалани низ segment_table (слика 12). Величина друге димензија низа диктира максималан број секција за један улаз  које решење подржава. 

 

    if(ph.filesz == 0) continue; //nema smisla alocirati sekciju slicnu bss sekciji 

 

uint64 pg_count = ph.memsz / PGSIZE; 

    if(ph.memsz % PGSIZE != 0) pg_count ++; 

    void * section_start; 

    for(int k = 0; k < pg_count; k ++) 

      section_start = kalloc(); 

     

    segment_table[i][j].page_count = pg_count; 

    segment_table[i][j].pg_pointer = section_start; 

 

    readi(i_temp, 0 , (uint64)section_start, ph.off, ph.filesz); 

Слика 11: Учитавање секција корисничких фајлова у оквиру функције 		  			init_alt_fs 

 

 

struct segment_meta 

{ 

  void * pg_pointer; 

  uint64 page_count; 

}; 

 

struct segment_meta segment_table [NINODE][NSEGMENTS]; 

 

 Слика 12: Структура у коју се смештају учитане секције 

Тиме се иницијализација завршава. 

Саме учитане секције се увезују са остатком оперативног система у оквиру exec системског позива тј. execout функције, односно приликом настанка адресног простора процеса.. 

 Уместо да се учитане секције опет учитавају са диска оне се, у случају постављеног W бита (који предвиђа упис у дату секцију), копирају у алоциране странице које се мапирају у оквиру табеле страница самог процеса. Уколико се не предвиђа упис у учитану секцију, онда нема потребе ни копирати секцију, већ се странице, алоциране приликом фазе иницијализације, мапирају у новонастали адресни простор. Тада се у оквиру самог улаза новонастале табеле страница, поставља нови бит, бит М (део кода 4), који индикује да се ради о дељеној страници. Претходно описани поступак увезивања учитаних секција са остатком фајл система је осликан на слици 13. 

writable = flags2perm(ph.flags)&PTE_W; 

    if(ph.filesz == 0 ) 

    { 

       if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz,  flags2perm(ph.flags))) == 0) 

      goto bad; 

    sz = sz1; 

    } 

   else  if(writable) 

    { 

    if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0) 

      goto bad; 

    sz = sz1; 

     

    if(copyout(pagetable,ph.vaddr,segment_table[ip->inum][i].pg_pointer,ph.filesz) == -1) 

      goto bad; 

    } 

    else{      

 	if(!sz && ph.vaddr) 

       { 

     

        if((sz1 = uvmalloc(pagetable, sz, PGROUNDDOWN(ph.vaddr)-1, flags2perm(ph.flags))) == 0) 

          goto bad; 

        sz = sz1; 

        } 

     else if((sz)&&(PGROUNDDOWN(sz) < (PGROUNDDOWN(ph.vaddr-1)))) 

        { 

     

      if((sz1 = uvmalloc(pagetable, sz, PGROUNDDOWN(ph.vaddr)-1, flags2perm(ph.flags))) == 0) 

        goto bad; 

      sz = sz1; 

      } 

 

      if((uint64)segment_table[ip->inum][i].pg_pointer == 0)panic("neucitan read only segment programa"); 

      if(mappages(pagetable, PGROUNDUP(ph.vaddr), ph.memsz,(uint64)segment_table[ip->inum][i].pg_pointer,PTE_M|PTE_R|PTE_U|flags2perm(ph.flags)) == -1)goto bad; 

 

 

      sz = ph.vaddr + ph.memsz; 

 

    } 

  } 

Слика 13: Мапирање станица у новонасталог адресног простор у оквиру функције еxecout 

#define PTE_M (1L << 5) //shared page 

Слика 14: Дефиниција бита М у оквиру riscv.h заглавља 

Остало је, у деловима оперативног система који су задужени за деалокацију и копирање страница процеса, додати условни код, који се извршава у случају да се ради о дељеној страници. 

У случају дељене странице, у првом делу (у оквиру функције uvmunmap) не треба је деалоцирати (слика 15). 

if(do_free){ 

      if((*pte & PTE_M) == 0) 

        { 

      uint64 pa = PTE2PA(*pte); 

      kfree((void*)pa); 

      } 

    } 

Слика 15: Модификовани део функције uvmunmap 

 

У случају дељене странице, у другом делу (у оквиру функције uvmcopy, слика 16) треба је додатно мапирати(уместо да се алоцира нова страница у коју њен садржај био прекопиран). 

shared = ((flags & PTE_M)); 

    if(shared==0 ) 

      { 

      if((mem = kalloc()) == 0) 

          goto err; 

      memmove(mem, (char*)pa, PGSIZE); 

      if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){ 

          kfree(mem); 

          goto err; 

        } 

      } 

    else 

      { 

      if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){ 

 

          goto err; 

        } 

      } 

  } 

Слика 16: Модификовани део функције uvmcopy 

 

 

Недостаци решења 

Решење које је приложено уз дипломски рад има неколико недостатака. 

За разлику од самих секција корисничких програма, одговарајућа заглавља као и само ЕЛФ заглавље се не учитавају у сами алтернативни фајл систем. То значи да та заглавља морају да се учитавају са диска сваки пут када се одговарајући процес покрене. 

Решење задатка такође наслеђује мане оригиналне имплементације, међу којима је и непотребна алокација страница и адресног простора за простор који се налази између фајл секција. Приложено решење само оптимизује непотребна учитавања са диска. 

Још један, можда више теоријски, недостатак јесте да се учитане странице корисничких програма користе само приликом његовог покретања. Уколико би неки процес желео да приступи фајловима другог програма, дошло би до поновног учитавања, у меморији већ присутних, блокова са диска. 

 

 

Закључак 

Генерално (и у грубим цртама) говорећи, меморија рачунара је мањег капацитета, док учитавање података из ње траје краће него са диска. Уколико је убрзавање рада рачунарског система један од циљева приликом његовог дизајна имало би смисла у меморију учитавати само информације за које је извесно да ће бити од значаја за само процесирање. 

У xv6 систему, учитавањем свих корисничких програма у меморију (уколико она за то уопште има и капацитета), чак и оних који се не користе непроседно, смањуе се капацитет меморије која би могла да се користи за потребе динамичке алокације меморијe, као и смештање недељивих страница процеса, чиме се повећава ризик да дође до феномена замене страница, а тиме и пада перформанси рачунарског система. 

Са друге стране уколико је за посматрани рачунарски систем од значаја да се процеси стварају са минималним закашњењем, поменута техника би донела позитивне резултате, нарочито уколико брзина саме иницијализације није од приоритета. 

Иако ограничене примене, сама идеја иза задатка овог дипломског рада представља занимљив експеримент, чија реализација представља добар начин за упознавање са елементима xv6 оперативног система. 

 

 

 

 

Литература 

Russ Cox, Frans Kaashoek, Robert Morris, xv6: a simple, Unix-like teaching operating system, September 5, 2022. 

https://wiki.qemu.org/Main_Page 